import pandas as pd
import numpy as np
import re
import traceback
from matplotlib import pyplot as plt
import calendar

RISKY_SQL_KEYWORDS = [
  "DROP", "DELETE", "UPDATE", "ALTER", "TRUNCATE",
  "INSERT", "REPLACE", "CREATE", "MERGE", "GRANT",
  "REVOKE", "EXEC", "CALL"
]

#Checks for queries that includes DML or similar commands that will manipulate/modify the data
def is_sql_risky(sql_query: str) -> bool:
  if not sql_query:
    return False
  sql_upper = sql_query.upper()
  for keyword in RISKY_SQL_KEYWORDS:
    if re.search(rf"\b{keyword}\b", sql_upper):
      return True
  return False

#Extracts SQL Query generated by SQL Chain
def extract_sql_query(llm_output: str) -> str | None:
  if not isinstance(llm_output, str):
    return None

  sql_blocks = re.findall(r"```sql(.*?)```", llm_output, re.DOTALL | re.IGNORECASE)
  if sql_blocks:
    return sql_blocks[0].strip().rstrip(";")

  code_blocks = re.findall(r"```(.*?)```", llm_output, re.DOTALL | re.IGNORECASE)
  for block in code_blocks:
    if re.search(r"\b(SELECT|INSERT|UPDATE|DELETE|WITH|ALTER|DROP)\b", block, re.IGNORECASE):
      return block.strip().rstrip(";")

  m = re.search(r"((SELECT|WITH|INSERT|UPDATE|DELETE|ALTER|DROP)[\s\S]+?)(;|$)", llm_output, re.IGNORECASE)
  if m:
    candidate = m.group(1).strip()
    return candidate.rstrip(";")

  return None

#Exectues the SQL query generated
def run_sql_query(sql_query, engine):
  try:
    with engine.connect() as conn:
      df = pd.read_sql(sql_query, conn)
      return df
  except Exception as e:
    return pd.DataFrame({"error": [f"SQL execution error: {e}"]})

#Removes return statements from the graph code
def remove_return_statements(code: str) -> str:
  cleaned_lines = []
  for line in code.splitlines():
    # Strip leading/trailing spaces for matching
    if "return" not in line.strip().split("#")[0]:  # ignore comments
      cleaned_lines.append(line)
  return "\n".join(cleaned_lines).strip()

#Removes read statements (eg. pd.read_csv()) from the graph code
def remove_df_read_csv(code: str) -> str:
  cleaned_lines = []
  pattern = re.compile(r"df\s*=\s*pd\.read_csv\s*\(", re.IGNORECASE)
  
  for line in code.splitlines():
    if not pattern.search(line):
      cleaned_lines.append(line)
  return "\n".join(cleaned_lines)

#Extracts python code generated by Graph Chain to plot a graph
def extract_python_code(llm_output: str) -> str:
  llm_output = remove_return_statements(llm_output)
  llm_output = remove_df_read_csv(llm_output)
  if not isinstance(llm_output, str):
    return ""
  py_blocks = re.findall(r"```python(.*?)```", llm_output, re.DOTALL | re.IGNORECASE)
  if py_blocks:
    return py_blocks[0].strip()
  code_blocks = re.findall(r"```(.*?)```", llm_output, re.DOTALL | re.IGNORECASE)
  if code_blocks:
    return code_blocks[0].strip()
  return llm_output.strip().strip("```").strip()

#Executes the generated graph code
def run_graph_code(graph_code, df):
  exec_globals = {
    "__name__": "__agent_graph__",
    "pd": pd,
    "np": np,
    "plt": plt,
    "calendar": calendar,
    "df": df.copy() if isinstance(df, pd.DataFrame) else df,
  }
  try:
    exec(graph_code, exec_globals)
    fig = exec_globals.get("fig", plt.gcf())
    if fig is None:
      raise RuntimeError("Graph code did not define a matplotlib figure named 'fig'.")
    plt.close(fig)
    return fig
  except Exception as e:
    print(f"Error executing graph code: {e}\n{traceback.format_exc()}")
    raise RuntimeError(f"Error executing graph code: {e}\n{traceback.format_exc()}")
